// Module included in the following assemblies:
//
// * operators/operator_sdk/osdk-golang-tutorial.adoc

[id="osdk-golang-implement-controller_{context}"]
= Implementing the controller

After creating a new API and controller, you can implement the controller logic.

.Procedure

* For this example, replace the generated controller file `controllers/memcached_controller.go` with the `memcached_controller.go` link:https://github.com/operator-framework/operator-sdk/blob/v1.2.0/testdata/go/memcached-operator/controllers/memcached_controller.go[example implementation].
+
The example controller executes the following reconciliation logic for each `Memcached` custom resource (CR):
+
--
* Create a Memcached deployment if it does not exist.
* Ensure that the deployment size is the same as specified by the `Memcached` CR spec.
* Update the `Memcached` CR status with the names of the `memcached` pods.
--

The next subsections explain how the controller watches resources and how the reconcile loop is triggered. You can skip these subsections to go directly to building and running the Operator.

[id="osdk-golang-implement-controller-resources_{context}"]
== Resources watched by the controller

The `SetupWithManager()` function in `controllers/memcached_controller.go` specifies how the controller is built to watch a CR and other resources that are owned and managed by that controller.

[source,go]
----
import (
	...
	appsv1 "k8s.io/api/apps/v1"
	...
)

func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cachev1alpha1.Memcached{}).
		Owns(&appsv1.Deployment{}).
		Complete(r)
}
----

`NewControllerManagedBy()` provides a controller builder that allows various controller configurations.

`For(&cachev1alpha1.Memcached{})` specifies the `Memcached` type as the primary resource to watch. For each `Memcached` type Add, Update, or Delete event, the reconcile loop is sent a reconcile `Request` argument, a namespace and name key, for that `Memcached` object.

`Owns(&appsv1.Deployment{})` specifies the `Deployment` type as the secondary resource to watch. For each `Deployment` type Add, Update, or Delete event, the event handler maps each event to a reconcile request for the owner of the deployment. In this case, the owner is the `Memcached` object for which the deployment was created.

[id="osdk-golang-implement-controller-configs_{context}"]
== Controller configurations

There are many other useful configurations that can be made when initializing a controller. For example:

* Set the max number of concurrent reconciles for the controller using the `MaxConcurrentReconciles` option, which defaults to `1`:
+
[source,go]
----
func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&cachev1alpha1.Memcached{}).
        Owns(&appsv1.Deployment{}).
        WithOptions(controller.Options{
            MaxConcurrentReconciles: 2,
        }).
        Complete(r)
}
----

* Filter watch events using predicates.

* Choose the type of link:https://godoc.org/sigs.k8s.io/controller-runtime/pkg/handler#hdr-EventHandlers[EventHandler] to change how a watch event translates to reconcile requests for the reconcile loop. For Operator relationships that are more complex than primary and secondary resources, the `EnqueueRequestsFromMapFunc` handler can be used to transform a watch event into an arbitrary set of reconcile requests.

For more details on these and other configurations, see the upstream link:https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/builder#example-Builder[Builder] and link:https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/controller[Controller] GoDocs.

[id="osdk-golang-implement-controller-reconcile-loop_{context}"]
== Reconcile loop

Every controller has a reconciler object with a `Reconcile()` method that implements the reconcile loop. The reconcile loop is passed the `Request` argument, which is a namespace and name key used to find the primary resource object, `Memcached`, from the cache:

[source,go]
----
import (
	ctrl "sigs.k8s.io/controller-runtime"

	cachev1alpha1 "github.com/example-inc/memcached-operator/api/v1alpha1"
	...
)

func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
  // Lookup the Memcached instance for this reconcile request
  memcached := &cachev1alpha1.Memcached{}
  err := r.Get(ctx, req.NamespacedName, memcached)
  ...
}
----

Based on the return values, result, and error, the request might be requeued and the reconcile loop might be triggered again:

[source,go]
----
// Reconcile successful - don't requeue
return ctrl.Result{}, nil
// Reconcile failed due to error - requeue
return ctrl.Result{}, err
// Requeue for any reason other than an error
return ctrl.Result{Requeue: true}, nil
----

You can set the `Result.RequeueAfter` to requeue the request after a grace period as well:

[source,go]
----
import "time"

// Reconcile for any reason other than an error after 5 seconds
return ctrl.Result{RequeueAfter: time.Second*5}, nil
----

[NOTE]
====
You can return `Result` with `RequeueAfter` set to periodically reconcile a CR.
====

For more on reconcilers, clients, and interacting with resource events, see the link:https://sdk.operatorframework.io/docs/building-operators/golang/references/client/[Controller Runtime Client API] documentation.

[id="osdk-golang-implement-controller-rbac-markers_{context}"]
== Permissions and RBAC manifests

The controller requires certain RBAC permissions to interact with the resources it manages. These are specified using RBAC markers, such as the following:

[source,go]
----
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;

func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
  ...
}
----

The `ClusterRole` object manifest at `config/rbac/role.yaml` is generated from the above markers using the `controller-gen` utility whenever the `make manifests` command is run.
